/*
 * Copyright (c) 2007, Manuel D. Rossetti (rossetti@uark.edu)
 *
 * Contact:
 *	Manuel D. Rossetti, Ph.D., P.E.
 *	Department of Industrial Engineering
 *	University of Arkansas
 *	4207 Bell Engineering Center
 *	Fayetteville, AR 72701
 *	Phone: (479) 575-6756
 *	Email: rossetti@uark.edu
 *	Web: www.uark.edu/~rossetti
 *
 * This file is part of the JSL (a Java Simulation Library). The JSL is a framework
 * of Java classes that permit the easy development and execution of discrete event
 * simulation programs.
 *
 * The JSL is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * The JSL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with the JSL (see file COPYING in the distribution);
 * if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301  USA, or see www.fsf.org
 *
 */
package jsl.modeling.elements;

import jsl.modeling.*;
import jsl.modeling.elements.variable.*;
import jsl.utilities.random.*;
import jsl.utilities.random.distributions.Constant;

/**
 * This class allows for the periodic generation of events similar to that
 * achieved by "Create" modules in simulation languages. This class works in
 * conjunction with the EventGeneratorListenerIfc which is used to listen and
 * react to the events that are generated by this class.
 *
 * Classes can supply an instance of an EventGeneratorListenerIfc to provide the
 * actions that take place when the event occurs. Alternatively, if no
 * EventGeneratorListenerIfc is supplied, by default the generator(JSLEvent
 * event) method of this class will be called when the event occurs. Thus,
 * sub-classes can simply override this method to provide behavior for when the
 * event occurs. If no EventGeneratorListenerIfc is supplied and the generate()
 * method is not overridden, then the events will still occur; however, no
 * meaningful actions will take place.
 *
 * Defaults:
 *
 * timeUntilFirst = Constant.ZERO timeUntilNext = Constant.POSITIVE_INFINITY
 * timeUntilLast = Double.POSITIVE_INFINITY maxNum = Long.MAX_VALUE
 *
 */
public class EventGenerator extends SchedulingElement implements EventGeneratorIfc {

    public final static int EVENT_PRIORITY = JSLEvent.DEFAULT_PRIORITY - 1;

    /**
     * Determines the priority of the event generator's events The default is
     * DEFAULT_PRIORITY - 1 A lower number implies higher priority.
     */
    private int myEventPriority = EVENT_PRIORITY;

    /**
     * Holds the random source for the time until first event. Used to
     * initialized the generator at the beginning of each replication
     *
     */
    private RandomIfc myInitialTimeUntilFirstEvent;

    /**
     * A RandomVariable that uses the time until first random source
     */
    private RandomVariable myTimeUntilFirstEventRV;

    /**
     * Holds the random source for the time between events. Used to initialized
     * the generator at the beginning of each replication
     *
     */
    private RandomIfc myInitialTimeBtwEvents;

    /**
     * A random variable for the time between events
     */
    private RandomVariable myTimeBtwEventsRV;

    /**
     * Used to set the ending time when the generator is initialized
     */
    private double myInitialEndingTime;

    /**
     * The time to stop generating for the current replication
     */
    private double myEndingTime;

    /**
     * Used to initialize the maximum number of events at the beginning of each
     * replication
     */
    private long myInitialMaxNumEvents;

    /**
     * The number of events to generate for the current replication
     */
    private long myMaxNumEvents;

    /**
     * The number of events currently generated during the replication
     */
    private long myEventCount;

    /**
     * Whether or not the generator is done generating
     */
    private boolean myDoneFlag;

    /**
     * Whether or not the generator has been suspended
     */
    private boolean mySuspendedFlag;

    /**
     * The next event to be executed for the generator
     */
    private JSLEvent myNextEvent;

    /**
     * Handles the actions for the event
     */
    private EventGeneratorListenerIfc myGenerateListener;

    /**
     * This flag controls whether or not the generator starts automatically when
     * initialized at the beginning of a replication By default this option is
     * true. If it is changed then it remains at the set value until changed
     * again.
     */
    private boolean myStartOnInitFlag = true;

    /**
     * Creates an EventGenerator that uses the supplied
     * EventGeneratorListenerIfc to react to the events. The default maximum
     * number of events to generate is infinite (Long.MAX_VALUE) Default time
     * between next is infinity. The default time of the first event is 0.0
     *
     * @param parent
     */
    public EventGenerator(ModelElement parent) {
        this(parent, null, Constant.ZERO, Constant.POSITIVE_INFINITY, Long.MAX_VALUE, Double.POSITIVE_INFINITY, null);
    }

    /**
     * Creates an EventGenerator that uses the supplied
     * EventGeneratorListenerIfc to react to the events. The default maximum
     * number of events to generate is infinite (Long.MAX_VALUE) Default time
     * between next is infinity. The default time of the first event is 0.0
     *
     * @param parent
     * @param listener This listener supplies the "event" logic for reacting to
     * the generated event.
     */
    public EventGenerator(ModelElement parent, EventGeneratorListenerIfc listener) {
        this(parent, listener, Constant.ZERO, Constant.POSITIVE_INFINITY, Long.MAX_VALUE, Double.POSITIVE_INFINITY, null);
    }

    /**
     * Creates an EventGenerator that uses the supplied
     * EventGeneratorListenerIfc to react to the events. The default maximum
     * number of events to generate is infinite (Long.MAX_VALUE) Default time
     * between next is infinity. The default time of the first event is 0.0
     *
     * @param parent
     * @param listener This listener supplies the "event" logic for reacting to
     * the generated event.
     * @param name The name of the generator.
     */
    public EventGenerator(ModelElement parent, EventGeneratorListenerIfc listener, String name) {
        this(parent, listener, Constant.ZERO, Constant.POSITIVE_INFINITY, Long.MAX_VALUE, Double.POSITIVE_INFINITY, name);
    }

    /**
     * Creates an EventGenerator that uses the supplied
     * EventGeneratorListenerIfc to react to the events. The default maximum
     * number of events to generate is infinite (Long.MAX_VALUE) Default time
     * between next is infinity.
     *
     * @param parent
     * @param listener This listener supplies the "event" logic for reacting to
     * the generated event.
     * @param timeUntilFirst A DistributionIfc object that supplies the time
     * until the first event
     *
     */
    public EventGenerator(ModelElement parent,
            EventGeneratorListenerIfc listener, RandomIfc timeUntilFirst) {
        this(parent, listener, timeUntilFirst, Constant.POSITIVE_INFINITY, Long.MAX_VALUE, Double.POSITIVE_INFINITY, null);
    }

    /**
     * Creates an EventGenerator that uses the supplied
     * EventGeneratorListenerIfc to react to the events. The default maximum
     * number of events to generate is infinite (Long.MAX_VALUE)
     *
     * @param parent
     * @param listener This listener supplies the "event" logic for reacting to
     * the generated event.
     * @param timeUntilFirst A RandomIfc object that supplies the time until the
     * first event.
     * @param timeUntilNext A RandomIfc object that supplies the time between
     * events. Must not be a RandomIfc that always returns 0.0, if the maximum
     * number of generations is infinite (Long.MAX_VALUE)
     *
     */
    public EventGenerator(ModelElement parent,
            EventGeneratorListenerIfc listener, RandomIfc timeUntilFirst,
            RandomIfc timeUntilNext) {
        this(parent, listener, timeUntilFirst, timeUntilNext, Long.MAX_VALUE, Double.POSITIVE_INFINITY, null);
    }

    /**
     * Creates an EventGenerator that uses the supplied
     * EventGeneratorListenerIfc to react to the events. The default maximum
     * number of events to generate is infinite (Long.MAX_VALUE) Default time
     * between next is infinity.
     *
     * @param parent
     * @param timeUntilFirst A RandomIfc object that supplies the time until the
     * first event.
     */
    public EventGenerator(ModelElement parent, RandomIfc timeUntilFirst) {
        this(parent, null, timeUntilFirst, Constant.POSITIVE_INFINITY, Long.MAX_VALUE, Double.POSITIVE_INFINITY, null);
    }

    /**
     * Creates an EventGenerator that uses the supplied
     * EventGeneratorListenerIfc to react to the events. The default maximum
     * number of events to generate is infinite (Long.MAX_VALUE)
     *
     * @param parent
     * @param timeUntilFirst A RandomIfc object that supplies the time until the
     * first event.
     * @param timeUntilNext A RandomIfc object that supplies the time between
     * events. Must not be a RandomIfc that always returns 0.0, if the maximum
     * number of generations is infinite (Long.MAX_VALUE)
     *
     */
    public EventGenerator(ModelElement parent, RandomIfc timeUntilFirst,
            RandomIfc timeUntilNext) {
        this(parent, null, timeUntilFirst, timeUntilNext, Long.MAX_VALUE, Double.POSITIVE_INFINITY, null);
    }

    /**
     * Creates an EventGenerator that uses the supplied
     * EventGeneratorListenerIfc to react to the events. The default maximum
     * number of events to generate is infinite (Long.MAX_VALUE)
     *
     * @param parent
     * @param timeUntilFirst A RandomIfc object that supplies the time until the
     * first event.
     * @param timeUntilNext A RandomIfc object that supplies the time between
     * events. Must not be a RandomIfc that always returns 0.0, if the maximum
     * number of generations is infinite (Long.MAX_VALUE)
     * @param name
     *
     */
    public EventGenerator(ModelElement parent, RandomIfc timeUntilFirst,
            RandomIfc timeUntilNext, String name) {
        this(parent, null, timeUntilFirst, timeUntilNext, Long.MAX_VALUE, Double.POSITIVE_INFINITY, name);
    }

    /**
     * Creates an EventGenerator that uses the supplied
     * EventGeneratorListenerIfc to react to the events. The default maximum
     * number of events to generate is infinite (Long.MAX_VALUE)
     *
     * @param parent
     * @param listener This listener supplies the "event" logic for reacting to
     * the generated event.
     * @param timeUntilFirst A RandomIfc object that supplies the time until the
     * first event.
     * @param timeUntilNext A RandomIfc object that supplies the time between
     * events. Must not be a RandomIfc that always returns 0.0, if the maximum
     * number of generations is infinite (Long.MAX_VALUE)
     * @param name
     *
     */
    public EventGenerator(ModelElement parent,
            EventGeneratorListenerIfc listener, RandomIfc timeUntilFirst,
            RandomIfc timeUntilNext, String name) {
        this(parent, listener, timeUntilFirst, timeUntilNext, Long.MAX_VALUE, Double.POSITIVE_INFINITY, name);
    }

    /**
     * Creates an EventGenerator that uses the supplied
     * EventGeneratorListenerIfc to react to the events.
     *
     * @param parent
     * @param listener This listener supplies the "event" logic for reacting to
     * the generated event.
     * @param timeUntilFirst A RandomIfc object that supplies the time until the
     * first event.
     * @param timeUntilNext A RandomIfc object that supplies the time between
     * events. Must not be a RandomIfc that always returns 0.0, if the maximum
     * number of generations is infinite (Long.MAX_VALUE)
     * @param maxNum A long that supplies the maximum number of events to
     * generate. Each time an event is to be scheduled the maximum number of
     * events is checked. If the maximum has been reached, then the generator is
     * turned off. The default is Long.MAX_VALUE. This parameter cannot be
     * Long.MAX_VALUE when the time until next always returns a value of 0.0
     *
     */
    public EventGenerator(ModelElement parent,
            EventGeneratorListenerIfc listener, RandomIfc timeUntilFirst,
            RandomIfc timeUntilNext, long maxNum) {
        this(parent, listener, timeUntilFirst, timeUntilNext, maxNum, Double.POSITIVE_INFINITY, null);
    }

    /**
     * Creates an EventGenerator that uses the supplied
     * EventGeneratorListenerIfc to react to the events.
     *
     * @param parent
     * @param listener This listener supplies the "event" logic for reacting to
     * the generated event.
     * @param timeUntilFirst A RandomIfc object that supplies the time until the
     * first event.
     * @param timeUntilNext A RandomIfc object that supplies the time between
     * events. Must not be a RandomIfc that always returns 0.0, if the maximum
     * number of generations is infinite (Long.MAX_VALUE)
     * @param maxNum A long that supplies the maximum number of events to
     * generate. Each time an event is to be scheduled the maximum number of
     * events is checked. If the maximum has been reached, then the generator is
     * turned off. The default is Long.MAX_VALUE. This parameter cannot be
     * Long.MAX_VALUE when the time until next always returns a value of 0.0
     * @param timeUntilLast A double that supplies a time to stop generating
     * events. When the generator is created, this variable is used to set the
     * ending time of the generator. Each time an event is to be scheduled the
     * ending time is checked. If the time of the next event is past this time,
     * then the generator is turned off and the event won't be scheduled. The
     * default is Double.POSITIVE_INFINITY.
     *
     */
    public EventGenerator(ModelElement parent,
            EventGeneratorListenerIfc listener, RandomIfc timeUntilFirst,
            RandomIfc timeUntilNext, long maxNum, double timeUntilLast) {
        this(parent, listener, timeUntilFirst, timeUntilNext, maxNum, timeUntilLast, null);
    }

    /**
     * Creates an EventGenerator that uses the supplied
     * EventGeneratorListenerIfc to react to the events.
     *
     * @param parent
     * @param listener This listener supplies the "event" logic for reacting to
     * the generated event.
     * @param timeUntilFirst A RandomIfc object that supplies the time until the
     * first event.
     * @param timeUntilNext A RandomIfc object that supplies the time between
     * events. Must not be a RandomIfc that always returns 0.0, if the maximum
     * number of generations is infinite (Long.MAX_VALUE)
     * @param maxNum A long that supplies the maximum number of events to
     * generate. Each time an event is to be scheduled the maximum number of
     * events is checked. If the maximum has been reached, then the generator is
     * turned off. The default is Long.MAX_VALUE. This parameter cannot be
     * Long.MAX_VALUE when the time until next always returns a value of 0.0
     * @param timeUntilLast A double that supplies a time to stop generating
     * events. When the generator is created, this variable is used to set the
     * ending time of the generator. Each time an event is to be scheduled the
     * ending time is checked. If the time of the next event is past this time,
     * then the generator is turned off and the event won't be scheduled. The
     * default is Double.POSITIVE_INFINITY.
     * @param name The name of the generator.
     */
    public EventGenerator(ModelElement parent,
            EventGeneratorListenerIfc listener, RandomIfc timeUntilFirst,
            RandomIfc timeUntilNext, long maxNum, double timeUntilLast, String name) {
        super(parent, name);

        setAfterReplicationOption(false);
        setEventGeneratorListener(listener);

        myDoneFlag = false;
        mySuspendedFlag = false;
        myEventCount = 0;
        myNextEvent = null;

        if (timeUntilFirst == null) {
            timeUntilFirst = Constant.ZERO;
        }

        setTimeUntilFirstEventForReplications(timeUntilFirst);
        myTimeUntilFirstEventRV = new RandomVariable(this, timeUntilFirst, getName() + " : Time Until First RV");

        if (timeUntilNext == null) {
            timeUntilNext = Constant.POSITIVE_INFINITY;
        }

        setTimeBetweenEventsForReplications(timeUntilNext, maxNum);

        setTimeBetweenEvents(myInitialTimeBtwEvents, myInitialMaxNumEvents);

        setGenerationEndingTimeForReplications(timeUntilLast);

        // set ending time based on the value to be used for each replication
        // setEndingTime(myInitialEndingTime);
    }

    /**
     * The priority of the events for the generator
     *
     * @return the event priority
     */
    public final int getEventPriority() {
        return myEventPriority;
    }

    /**
     * Lower means earlier (higher priority). Changing the priority effects only
     * future scheduled events The changed priority is retained for all future
     * replications
     *
     * @param priority the priority to set
     */
    public final void setEventPriority(int priority) {
        myEventPriority = priority;
    }

    /**
     * Sets the listener for the events to the supplied
     * EventGeneratorListenerIfc
     *
     * @param listener This listener supplies the "event" logic for reacting to
     * the generated event.
     */
    public final void setEventGeneratorListener(EventGeneratorListenerIfc listener) {
        myGenerateListener = listener;
    }

    /**
     * Gets the listener for the events to the supplied
     * EventGeneratorListenerIfc. This can be null. If null, the
     * generate(JSLEvent event) method is called.
     *
     * @return
     */
    public final EventGeneratorListenerIfc getEventGeneratorListener() {
        return (myGenerateListener);
    }

    /**
     * This flag indicates whether or not the generator will automatically start
     * at the beginning of a replication when initialized. By default this
     * option is true.
     *
     * @return
     */
    @Override
    public final boolean getStartOnInitializeFlag() {
        return myStartOnInitFlag;
    }

    /**
     * Sets the flag that indicates whether or not the generator will
     * automatically start at the beginning of a replication when initialized
     *
     * @param flag
     */
    @Override
    public final void setStartOnInitializeFlag(boolean flag) {
        myStartOnInitFlag = flag;
    }

    /**
     * If the generator was not started upon initialization at the beginning of
     * a replication, then this method can be used to start the generator
     *
     * The generator will be started t time units after the call
     *
     * If this method is used when the generator is already started it does
     * nothing. If this method is used after the generator is done it does
     * nothing. If this method is used after the generator has been suspended it
     * does nothing. Use suspend() and resume() to suspend and resume a
     * generator that has already been started.
     *
     * @param t The time until the generator should be turned on
     */
    @Override
    public final void turnOnGenerator(double t) {
//		System.out.println("************************************  in turnOnGenerator() " + getName());
        if (mySuspendedFlag == true) {
            return;
        }
        if (myDoneFlag == true) {
            return;
        }
        if (myMaxNumEvents == 0) {
            return;
        }
        if (myEventCount >= myMaxNumEvents) {
            return;
        }
        if (myNextEvent != null) {
            return;
        }
//		System.out.println("************************************ scheduling the generator's first event for time " + (t + getTime()));
        // not suspended, not done, has events, no event pending
        scheduleFirstEvent(t);
    }

    /**
     * If the generator was not started upon initialization at the beginning of
     * a replication, then this method can be used to start the generator
     *
     * The generator will be started r.getValue() time units after the call
     *
     * If this method is used when the generator is already started it does
     * nothing. If this method is used after the generator is done it does
     * nothing. If this method is used after the generator has been suspended it
     * does nothing. Use suspend() and resume() to suspend and resume a
     * generator that has already been started.
     *
     * @param r The time until the generator should be turned on
     */
    @Override
    public void turnOnGenerator(RandomIfc r) {
        turnOnGenerator(r.getValue());
    }

    /**
     * If the generator was not started upon initialization at the beginning of
     * a replication, then this method can be used to start the generator
     *
     * The generator will be started 0.0 time units after the call
     *
     * If this method is used when the generator is already started it does
     * nothing. If this method is used after the generator is done it does
     * nothing. If this method is used after the generator has been suspended it
     * does nothing. Use suspend() and resume() to suspend and resume a
     * generator that has already been started.
     *
     */
    @Override
    public final void turnOnGenerator() {
        turnOnGenerator(0.0);
    }

    /**
     * This method turns the generator off, the next scheduled generation event
     * will NOT occur, i.e. this method will also cancel a previously scheduled
     * generation event if one exists. No future events will be scheduled after
     * turning off the generator. Once the generator has been turned off, it
     * cannot be restarted until the next replication. Use suspend() and
     * resume() for on/off behavior during a replication
     */
    @Override
    public final void turnOffGenerator() {
        myDoneFlag = true;
        if (myNextEvent != null) {
            if (myNextEvent.isScheduled()) {
                cancelEvent(myNextEvent);
            }
        }
    }

    /**
     * Suspends the generation of events and cancels the next scheduled event
     * from the generator
     */
    @Override
    public final void suspend() {
        mySuspendedFlag = true;
        if (myNextEvent != null) {
            if (myNextEvent.isScheduled()) {
                cancelEvent(myNextEvent);
            }
        }
    }

    /**
     * Indicates whether or not the generator has been suspended
     *
     * @return
     */
    @Override
    public final boolean isSuspended() {
        return (mySuspendedFlag);
    }

    /**
     * Resume the generation of events according to the time between event
     * distribution.
     */
    @Override
    public final void resume() {
        if (isSuspended()) {
            mySuspendedFlag = false;
            // get the time until next event
            double t = myTimeBtwEventsRV.getValue();
            // check if it is past end time
            if (t + getTime() > myEndingTime) {
                turnOffGenerator();
            }

            if (myDoneFlag == false) // I'm not done generating, schedule the event
            {
                myNextEvent = scheduleEvent(t, JSLEvent.DEFAULT_TYPE, myEventPriority);
            }
        }
    }

    /**
     * This method checks to see if the generator is done. In other words, if it
     * has been turned off.
     *
     * @return True means that it is done.
     */
    @Override
    public final boolean isGeneratorDone() {
        return (myDoneFlag);
    }

    /**
     * Gets the maximum number of actions for the generator. This is set by the
     * supplied maxNum upon creation of the generator. This implies that it will
     * be the same for every simulation replication.
     *
     * @return A long representing the maximum number of actions for the
     * generator.
     */
    @Override
    public final long getMaximumNumberOfEvents() {
        return (myMaxNumEvents);
    }

    /**
     * Gets the random source controlling the time between events
     *
     * @return
     */
    @Override
    public final RandomIfc getTimeBetweenEvents() {
        return myTimeBtwEventsRV.getRandomSource();
    }

    /**
     * Sets the time between event random source. Must not always evaluate to
     * 0.0, if the current setting of the maximum number of events is infinite
     * (Long.MAX_VALUE)
     *
     * @param timeUntilNext
     */
    @Override
    public final void setTimeBetweenEvents(RandomIfc timeUntilNext) {
        setTimeBetweenEvents(timeUntilNext, myMaxNumEvents);
    }

    /**
     * Sets the maximum number of events for the generator. Must not be infinite
     * (Long.MAX_VALUE) if the current time between events is 0.0
     *
     * @param maxNum
     */
    @Override
    public final void setMaximumNumberOfEvents(long maxNum) {
        setTimeBetweenEvents(myTimeBtwEventsRV.getRandomSource(), maxNum);
    }

    /**
     * Sets the time between events and the maximum number of events for the
     * generator. These two parameters are dependent. The time between events
     * cannot always evaluate to 0.0 (i.e. cannot be a Constant with value zero)
     * if the maximum number of events is infinite (Long.MAX_VALUE). This method
     * only changes these parameters for the current replication. The changes
     * take effect when the next event is generated. If current number of events
     * that have been generated is greater than or equal to the supplied maximum
     * number of events, the generator will be turned off.
     *
     * @param timeBtwEvents
     * @param maxNumEvents
     */
    @Override
    public final void setTimeBetweenEvents(RandomIfc timeBtwEvents, long maxNumEvents) {
        if (maxNumEvents < 0) {
            throw new IllegalArgumentException("The maximum number of actions was < 0!");
        }

        if (timeBtwEvents == null) {
            throw new IllegalArgumentException("The time until next distribution was null!");
        }

        if (maxNumEvents == Long.MAX_VALUE) {
            if (timeBtwEvents instanceof Constant) {
                if (timeBtwEvents.getValue() == 0.0) {
                    throw new IllegalArgumentException("Maximum number of actions is infinite and time between actions is 0.0");
                }
            }
        }

        // time btw events is okay and max num events is okay
        myMaxNumEvents = maxNumEvents;
        if (myTimeBtwEventsRV == null) {
            myTimeBtwEventsRV = new RandomVariable(this, timeBtwEvents, getName() + " : Time Btw Events RV");
        } else {
            myTimeBtwEventsRV.setRandomSource(timeBtwEvents);
        }

        // if number of events is >= desired number of events, turn off the generator
        if (myEventCount >= maxNumEvents) {
            turnOffGenerator();
        }
    }

    /**
     * Sets the time between events and the maximum number of events to be used
     * to initialize each replication. The time between events cannot evaluate
     * to a constant value of 0.0. The maximum number of events is kept at its
     * current value
     *
     * @param timeBtwEvents
     */
    @Override
    public final void setTimeBetweenEventsForReplications(RandomIfc timeBtwEvents) {
        setTimeBetweenEventsForReplications(timeBtwEvents, myInitialMaxNumEvents);
    }

    /**
     * Sets the the maximum number of events to be used to initialize each
     * replication. The time between events cannot evaluate to a constant value
     * of 0.0 if the maximum number of events is infinite (Long.MAX_VALUE). Uses
     * the current value for initial time between events
     *
     * @param maxNumEvents
     */
    @Override
    public final void setMaximumNumberOfEventsForReplications(long maxNumEvents) {
        setTimeBetweenEventsForReplications(myInitialTimeBtwEvents, maxNumEvents);
    }

    /**
     * Sets the time between events and the maximum number of events to be used
     * to initialize each replication. These parameters are dependent. The time
     * between events cannot evaluate to a constant value of 0.0 (i.e. cannot be
     * Constant with value zero) if the maximum number of events is infinite
     * (Long.MAX_VALUE)
     *
     * These will be used to initialize each replication
     *
     * @param timeBtwEvents
     * @param maxNumEvents
     */
    @Override
    public final void setTimeBetweenEventsForReplications(RandomIfc timeBtwEvents, long maxNumEvents) {
        if (timeBtwEvents == null) {
            throw new IllegalArgumentException("The time between events was null!");
        }

        if (maxNumEvents < 0) {
            throw new IllegalArgumentException("The maximum number of events to generate was < 0!");
        }

//		System.out.println("^^^^^^^^^^^^^^^^  In setTimeBetweenEventsForReplication() for " + getName());
//		System.out.println("timeBtwEvents " + timeBtwEvents + " maxNumEvents = " + maxNumEvents);
        if (maxNumEvents == Long.MAX_VALUE) {
            if (timeBtwEvents instanceof Constant) {
                if (timeBtwEvents.getValue() == 0.0) {
                    throw new IllegalArgumentException("Maximum number of actions is infinite and time between actions is 0.0");
                }
            }
        }

        myInitialMaxNumEvents = maxNumEvents;
        myInitialTimeBtwEvents = timeBtwEvents;
    }

    /**
     * Returns the time between events used to initialize each replication
     *
     * @return
     */
    @Override
    public final RandomIfc getTimeBetweenEventsForReplications() {
        return (myInitialTimeBtwEvents);
    }

    /**
     * Returns the maximum number of events that is used for initializing each
     * replication
     *
     * @return
     */
    @Override
    public final long getMaximumNumberOfEventsForReplications() {
        return (myInitialMaxNumEvents);
    }

    /**
     * Sets the RandomIfc representing the time until the first event that is
     * used at the beginning of each replication to generate the time until the
     * first event. This change becomes effective at the beginning of the next
     * replication to execute
     *
     * @param timeUntilFirst The supplied RandomIfc, cannot be null
     */
    @Override
    public final void setTimeUntilFirstEventForReplications(RandomIfc timeUntilFirst) {
        if (timeUntilFirst == null) {
            throw new IllegalArgumentException("The time until first RandomIfc was null!");
        }

        myInitialTimeUntilFirstEvent = timeUntilFirst;
    }

    /**
     * Gets the RandomIfc that will be used at the beginning of each replication
     * to generate the time until the first event
     *
     * @return
     */
    @Override
    public final RandomIfc getTimeUntilFirstEventForReplications() {
        return (myInitialTimeUntilFirstEvent);
    }

    /**
     * Sets the ending time for generating events for the current replication. A
     * new ending time will be applied to the generator. If this change results
     * in an ending time that is less than the current time, the generator will
     * be turned off
     *
     * @param endingTime the desired time to stop generating
     */
    @Override
    public final void setEndingTime(double endingTime) {
        if (endingTime < 0) {
            throw new IllegalArgumentException("The ending time was < 0.0!");
        }

        if (endingTime < getTime()) {
            turnOffGenerator();
        } else // now set the time to turn off
        {
            myEndingTime = endingTime;
        }
    }

    /**
     * Gets the currently planned ending time of the generator.
     *
     * @return A double representing the ending time.
     */
    @Override
    public final double getEndingTime() {
        return (myEndingTime);
    }

    /**
     * This value is used to set the ending time for generating actions for each
     * replication. Changing this variable during a replication cause the next
     * replication to use this value for its ending time.
     *
     * @param endingTime
     */
    @Override
    public final void setGenerationEndingTimeForReplications(double endingTime) {
        if (endingTime < 0) {
            throw new IllegalArgumentException("The time until last was < 0.0!");
        }
        myInitialEndingTime = endingTime;
    }

    /**
     * Returns the ending time that is to be used when the generator is
     * initialized for each replication.
     *
     * @return
     */
    @Override
    public final double getGenerationEndingTimeForReplications() {
        return (myInitialEndingTime);
    }

    /**
     * Gets the number of events that have been generated by the generator
     *
     * @return
     */
    @Override
    public final long getNumberOfEventsGenerated() {
        return (myEventCount);
    }

    @Override
    protected void initialize() {
//		System.out.println("************************** In initialize() for: " + getName());
        myDoneFlag = false;
        mySuspendedFlag = false;
        myEventCount = 0;
        myNextEvent = null;
        // set ending time based on the value to be used for each replication
        setEndingTime(myInitialEndingTime);
        // set the time until first event based on the value to be used for each replication
        myTimeUntilFirstEventRV.setRandomSource(myInitialTimeUntilFirstEvent);

        //set the time between events, maximum number of events based on the values to be used for each replication
        setTimeBetweenEvents(myInitialTimeBtwEvents, myInitialMaxNumEvents);
        if (myStartOnInitFlag) {
            if (myMaxNumEvents > 0) {
                scheduleFirstEvent(myTimeUntilFirstEventRV);
            }
        }
    }

    /**
     * This method should be overridden by sub-classes that do not supply an
     * EventGeneratorListenerIfc to model the action that occur when the event
     * happens.
     *
     * @param event
     */
    protected void generate(JSLEvent event) {
    }

    /**
     * Schedules the first event at current time + r.getValue()
     *
     * @param r
     */
    protected final void scheduleFirstEvent(RandomIfc r) {
        scheduleFirstEvent(r.getValue());
    }

    /**
     * Schedules the first event at current time + t
     *
     * @param t
     */
    protected final void scheduleFirstEvent(double t) {
//		System.out.println("Scheduling the first event");
        // check if it is past end time
//		System.out.println(getName() + " in scheduleFirstEvent(double t) myEndingTime = " + myEndingTime);
        if (t + getTime() > myEndingTime) {
            turnOffGenerator();
        }

        if (myDoneFlag == false) // I'm not done generating, schedule the first event
        {
            myNextEvent = scheduleEvent(t, JSLEvent.DEFAULT_TYPE, myEventPriority);
        }
    }

    /**
     * Increments the number of actions and checks if the number of actions is
     * greater than the maximum number of actions. If so, the generator is told
     * to shut down.
     */
    protected final void incrementNumberOfEvents() {
        myEventCount++;
        if (myEventCount > myMaxNumEvents) {
            myDoneFlag = true;
        }
    }

    /**
     * Specifies the action that occurs when the generate event listener is
     * called.
     *
     * @param event
     */
    @Override
    protected final void handleEvent(JSLEvent event) {

        incrementNumberOfEvents();

        if (myDoneFlag == false) {
            if (myGenerateListener != null) {
                myGenerateListener.generate(this, event);
            } else {
                generate(event);
            }

            // get the time until next event
            double t = myTimeBtwEventsRV.getValue();
            // check if it is past end time
            if (t + getTime() > myEndingTime) {
                turnOffGenerator();
            }

            if (!isSuspended()) {
                if (myDoneFlag == false) // I'm not done generating, schedule the next event
                {
                    rescheduleEvent(event, t);
                }
            }
        }
    }

    @Override
    protected void removedFromModel() {
        super.removedFromModel();
        myInitialTimeUntilFirstEvent = null;
        myTimeUntilFirstEventRV = null;
        myInitialTimeBtwEvents = null;
        myTimeBtwEventsRV = null;
        myNextEvent = null;
        myGenerateListener = null;
    }
}
